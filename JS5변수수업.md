> 수학에서의 ' 변수 ' : 아직 값이 결정되지 않은 것 (  X + 1 = 2  )

*front vs back-end 

> user interface의 차이 (사용자의 접점의 차이)
> front: ' 사용자들이 사용할 때 이 접점이 편할까 아닐까 '



*[Application][일을 할 때 사용하는 프로그램이고 동적이다]?

> [데이터][입력으로 받은 데이터를 가공해서 아웃풋으로 뱉어내는것(landering)]를 다루는 것 (IPO)

![스크린샷 2020-11-18 오후 1.15.51](/Users/jeonsejin/Library/Application Support/typora-user-images/스크린샷 2020-11-18 오후 1.15.51.png) 



# 변수

> [**하나의 값**][메모리 공간 내에는 하나의 값이 들어갈 수 있다는 것을 의미합니다.]을 저장하기 위해 확보한 메모리공간 자체 
> 메모리공간을 가르키는 이름 (식별하기 위해 붙인 이름)
>
> ```js
> Q) 여러개 값은?
> A) 자료구조 : 여러개의 값을 하나의 그룹화해서 사용하는 것 (여러 개)
> 	-다양한 상황에서 어떠한 자료구조를 사용할 수 있는가? 
>   -각각의 자료구조 특징을 공부하고 장/단점 비교가 되어야 한다. 
> ```
>
> > 데이터와 핵심 밀접한 개념  



<process를 이해해보자>

```js
10 + 20
//human
읽어들이는 행위 > 해석 > 기억 > 계산 > 결과 값 기억해서 출력
// computer
읽어들이는 행위: 한 글자씩 메모리속으로 불러들이는 것 
해석해서 2진수로 변환해서 메모리에 저장한다
```



### 1.바이트(byte) vs 비트(bit)



<img src="/Users/jeonsejin/Desktop/스크린샷 2020-11-18 오후 1.33.26.png" alt="스크린샷 2020-11-18 오후 1.33.26" style="zoom: 50%;" /> 



```js
//컴퓨터는 2진수의 0과 1형태만 이해하고 사용할 수 있습니다.
//byte :8개의 단위의 비트(8bit)를 하나의 그룹으로 사용하는 것
//>주소 지정이 가능한 단일 저장소 
//>1바이트: 0-255까지의 값 소유 

//bit(binary): 1은 전원의 'on'/ 0은 전원의 'off'
//Q) 1byte = 8bit ?
//A) ASCII Code(데이터 문자) 조사하기 
	  // Unicode 조사하기 
```



### 2.메모리

<img src="/Users/jeonsejin/Library/Application Support/typora-user-images/스크린샷 2020-11-18 오후 1.39.25.png" alt="스크린샷 2020-11-18 오후 1.39.25" style="zoom:50%;" /> 

- 메모리 vs 하드디스크 

| 메모리(CPU)      | 하드디스크          |
| ---------------- | ------------------- |
| 휘발성 데이터    | 장기적 데이터       |
| 전원 공급 > 저장 | 전원 공급 X > 저장  |
| 단기적 기억      | 장기적, 영속적 기억 |

- 컴퓨터 

  > OS가 어떤 메모리 셀을 사용중인지 아닌지 파악 후 사용하지 않는 영역을 
  > 자바스크립트 엔진에게 알려준다.
  > 그 후, 자바스크립트 엔진이 2진수로 변환한 것을 저장하여 cpu가 계산한다.
  > 계산 한  결과 값은 한번만 사용할 수 있다. 



```js
console.log(1 + 2);
>3
```

```js
Q) 변수를 재사용하는 방법은 ?
A) 메모리 주소를 인간이 알아서 명령어를 통해 메모리 셀을 가져오라고 할 수 있음 > 그러나 불허. 
	=인간은 실수를 할까봐 주소 안알려줌 > 사람이 잘 이해할 수 있는" 주소의 이름"을 가지고 있음 
    > "이름"이 "메모리의 주소"를 기억한다. 
    > "이름"을 "변환"해서 "재사용"

<변수("이름")의 장점>
  1) 실수 가능성 하락(maping) 
	2) 사람이 이해할 수 있는 언어 > 잘 이해한다 
```



## 변수를 사용하는 방법

```js
//Q) Keyword?
//A) 자바스크립트 엔진은 알고 있기 때문에 
//var를 만나면 무엇을 해야하는지 알고 있고 그것을 하게 해주는 것 
```

- 변수선언 

  ```js
  var result; ( 변수선언키워드  변수이름  세미콜론 = 문 ) 
  ```

  | Javascript                     | C                                |
  | ------------------------------ | -------------------------------- |
  | 구체적으로 바이트 확보 알 수 X | Int 변수이름 (정수) :4바이트     |
  |                                | Float 변수이름(소수점) : 8바이트 |
  |                                | char 변수이름(문자열) :1바이트   |
  | 메모리 공간 크기 알수 x        | 메모리 공간크기 알수 O           |
  | 암묵적으로 초기화 (명시적 X)   | 초기화 안하면 그냥 비워둠.       |

  > 1.선언단계 : 변수이름을 자바스크립트 엔진에 [등록한다](자바스트립트 엔진이 갖고있는 표(환경record)에 등록한다(알린다))
  >
  > * Declaration(선언) : 많은 사람들에게 내가 이것을 할 것이다라고 공표하는 것
  >
  > * 변수선원 키워드 
  >
  >   * Var / let / const
  >   * var의 단점을 파악하고 let과 const가 var의 단점을 어떻게 해결했을까? 
  >
  >   
  >
  > 2.[초기화][개발자가 변수선언 이후 최초로 값을 할당하는 것] 단계(암묵적 초기화): 메모리공간을 확보한다.
  >
  > - 메모리 공간을 " 확보 " 한다. 
  >
  >   - [쓰레기 값][이전에 남아있던 의미없는 값]을 지우기 위해서. 
  >
  >   
  >
  > - 메모리 공간을 암묵적으로[ *'undefined' ][정의되지 않았다]를 '알아서' 채워둠.
  >
  >   - *초기화가 되지 않았다. = 초기화 되지 않은 변수 
  >   - <u>"**암묵적으로는** 초기화가 되었지만 (자바스크립트 엔진이알아서 함)</u>
  >     <u>내가 직접 초기화하지 않았으므로 **명시적으로** 초기화가 되지 않은 것이다. "</u>
  >   - Defined(정의) : 아직 명확하지 않은 것을 명확하게 하는 것 
  >     - 할당을 통해 명확하게 하는 것 
  >
  >   ```js
  >   var sum; //변수 선언(선언문)
  >   sum = 1; //할당(=초기화)(할당문)
  >   
  >   //변수 선언 + 할당한 2개의 축약형이라는 것을 잊지말자.
  >   var sum = 1; 
  >   
  >   //0을 할당 : 0으로 초기화하고 시작한다는 의미를 개발자들이 이해.
  >   //암묵적으로 초기화하는 값이 정해져 있다 (convention)
  >   //등록된 sum에 가서 찾으면 메모리에 접근해서 값을 끄집어 내는 것 
  >   var sum = 0;
  >   console.log(sum); //0 
  >   
  >   <variable hoisting>
  >   //sum이 정의되기 전에 사용되었다. 
  >   //등록이 안되있으니 reference error가 발생해야 하는데, 안 발생 Why?
  >   //runtime에 들어가기 직전에 선언문을 먼저 끄집어내서 하기 때문이다.
  >   console.log(sum);
  >   var sum = 0; //undefined 
  >   
  >   Q) 왜 이런 현상이 발생할까?
  >   A) 자바스크립트 엔진은 
  >   	 var sum; //변수 선언문 : "runtime이전에 " 미리 실행
  >   	 sum =0; //할당문 :" runtime에 " 실행 
  >   //runtime: 한줄 한줄 실행하는 것 (소스코드가 실행되는 시점)
  >   //선언문은 가장 먼저 실행된다.
  >   
  >   //순서 
  >   1) var sum;
  >   2) console.log(Sum); //undefined 
  >   3) sum = 0; //0
  >   ```
  >
  >   
  >
  >   > <variable hoistion>
  >   >
  >   > > 이런 부작용이 있으니 사용하지 말아라 라는 것을 배우기 위함이다. 
  >   > >
  >   > > ```js
  >   > > var sum;
  >   > > console.log(Sum); //이런 코드 쓰지 말아라.
  >   > > ```
  >
  >   
  >
  >   > <garbage collector>
  >   >
  >   > - 메모리공간의 확보 : OS에게 이 공간에 값이 들어있다라는 것을 알려주는 것 > lock
  >   > - 메모리공간의 해제: undefined의 공간을 해제하는 것 
  >
  >   
  >
  >   > <원시 값과 값의 재할당 >
  >   >
  >   > ```js
  >   > var sum = 0; //할당
  >   > console.log(Sum); 
  >   > sum = 10; //재할당
  >   > sum = 100; //재할당
  >   > 
  >   > console.log(Sum); //undefined 
  >   > var sum = 0; 
  >   > console.log(Sum); //0
  >   > var sum = 10;
  >   > console.log(Sum); //10
  >   > //재할당을 통해서 변수의 값을 변경할 수 있다. 
  >   > //변수 값? 메모리 공간안에 들어 있는 값 
  >   > ```
  >   >
  >   > <img src="/Users/jeonsejin/typoraimge/원시값.jpg" alt="원시값" style="zoom: 25%;" /> <img src="/Users/jeonsejin/typoraimge/재할당.jpg" alt="재할당" style="zoom: 25%;" /> 
  >   >
  >   > - [원시 값][primitive : 정해지면 변하지 않는 불변의 값] : immutable value : 한번 메모리 공간에 자리 잡으면 **" 변하지 않는 값"**
  >   >
  >   >   - 원시 값을 " **재할당** "하면 식별자가 기억하는 메모리주소가 바뀐다.
  >   >   - 주소를 안바꾸면서 원시 값을 바꾼다?  X
  >   >
  >   > - [객체 ][만들어지면 변하는 값] : 한번 메모리공간에 자리잡아도  **"변하는 값"**
  >   >
  >   > - 변수의 값 =/ 값 자체 
  >   >
  >   >   ```js
  >   >   var foo = 1;
  >   >   foo = 2;
  >   >   //변수 값이 변한 것 (1 ->2 ) 과 값 자체 (1 & 2)는 다른 것.
  >   >   
  >   >   const foo =1;
  >   >   //상수 constant : 재할당 할 수 없다.
  >   >   
  >   >   console.log(foo);
  >   >   let foo = 1;
  >   >   foo=2;
  >   >   //let은 재할당 할 수 있다. 
  >   >   //변수 호이스팅 error
  >   >   ```





## 값의 교환

### 1.TEMP방법 사용

<img src="/Users/jeonsejin/Library/Application Support/typora-user-images/스크린샷 2020-11-18 오후 3.49.14.png" alt="스크린샷 2020-11-18 오후 3.49.14" style="zoom: 67%;" />  <img src="/Users/jeonsejin/typoraimge/ㄴㄴㄴ.jpg" alt="ㄴㄴㄴ" style="zoom:25%;" />

### 2.배열 비구조화 할당

<img src="/Users/jeonsejin/Library/Application Support/typora-user-images/스크린샷 2020-11-18 오후 3.53.16.png" alt="스크린샷 2020-11-18 오후 3.53.16" style="zoom: 67%;" /> 



## 식별자

- 하나의 메모리상에 저장되어있는 여러개의 값 중에 하나의 값을 식별할 수 있어야 하는 것 
- 메모리 주소에 붙인 이름
- 변수이름은 모두 식별자지만 식별자는 모두 변수이름이 될 수 없다. (변수이름 > 식별자)

```
Q) 어떻게 하나의 값을 식별할 수 있는가?
A) 식별자가 key가 되어서 key로 메모리주소를 알 수 있어야 식별할 수 있다. 
	 -변수이름(식별자)를 알고 있으면 메모리주소를 알 수 있다.
	 >메모리에 저장된 값을 가져오기 위해서 식별자를 알아야 하는 것입니다.
	 -메모리주소를 알고 있으면 식별자를 알 수 있다?? XXXXX
```

```
Q) 변수에 국한된 용어인가요?
A) 다양한 무언가 중에서 한가지를 골라낼 수 있다면 그것이 식별자 입니다.( ex: 주민등록번호 / 도메인 / 파일명 )
	Q) 파일을 abc라는 파일을 만들면 또 다른 파일을 abc라고 이름을 못짓는가? 
	A) NO! 존재할 수 있지만 "폴더가 달라야 한다" (조건)
		Q) 변수이름 result는 또 다시 이름으로 사용할 수 없는가?
		A) 이해하기 위해서 [scope][폴더가 다른것]를 공부하자 
```



## 식별자의 네이밍규칙

### 가독성 > 효율성

- 가독성 장점
  - 버그 발생확률 낮음
  - 유지보수 쉬움
- 효율성 장점
  - 처리속도 빠름(시간적) 
  - 메모리 적게 소비(공간적)

```js
var person, $elem, _name, first_name, val1;
//$ , _(언더스코어) : 위치 상관 없이 사용가능하다. 
```

```js
//SyntaxError 
// ' - '(뺄셈) : 좌항과 우항은 숫자타입이어야 하는데 문자이기 때문에 안됩니다.
var first-name; // SyntaxError: Unexpected token –
var 1st;        // SyntaxError: Invalid or unexpected token
var this;       // SyntaxError: Unexpected token this
```

```js
//대소문자 구별하세요. 3가지는 각각 별개의 변수입니다. < - > html은 대소문자 구별 하지 않습니다.
//네이밍컨벤션을 잘 지켜주세요. (naming convention) 
//상수인 경우, 대부분 대문자를 사용합니다.
var firstname;
var firstName;
var FIRSTNAME;
```

```js
//변수가 할당되는 값의 이름을 제대로 지어주어야 합니다.
//변수의 이름은 가독성이 좋아야 합니다. 
var x = 3;       // NG. x 변수가 의미하는 바를 알 수 없다.
var score = 100; // OK. score 변수는 점수를 의미한다.
```

- naming convention (약속) : **일관성**을 유지하는 것이 point!

  ```js
  // 카멜 케이스 (camelCase) : 일반 식별자
  var firstName;
  
  // 스네이크 케이스 (snake_case) 
  var first_name;
  
  // 파스칼 케이스 (PascalCase) : 클래스의 이름/ 함수를 나타내는 객체의 이름으로 많이 사용
  var FirstName;
  
  // 헝가리언 케이스 (typeHungarianCase) 
  // 변수에 어떤 값을 할당해야 하는지 알려주는 것 
  var strFirstName; // type + identifier
  
  // DOM 노드
  //$를 앞에 붙여주면 HTML요소를 가져오는 것 ( HTML요소 = node 객체 )
  var $elem = document.getElementById('myId'); 
  
  //RxJS 옵저버블
  var observable$ = fromEvent(document, 'click'); 
  ```

  

  **"  *주석이 없는 코드가 가장 완벽하다.  "** 

