# Operator('연산자')

```
Q) number ++ 와 재할당의 차이는 뭘까?
	 number ++는 10을 메모리에 할당 한 후 1을 더해서 11이라는 값을 또 할당할 텐데 
	 그러면 재할당이랑 다른게 뭐지?
	 
Q) ++number는 10인 값이 +1을 더해서 11로 값이 변경되어서 암묵적으로 11이 할당되는 것?

Q)var x = '1'도 문자열이고 x ='hello'도 문자열인데 
	console.log(+x);는 1로 숫자타입으로 변환이 가능한데 왜 console.log(+x);는 숫자타입으로
  변환이 되지 않아서 NaN(Not a Number)을 반환하는 것일까? 
```



> 하나 이상의 표현식을 대상으로 산술, 연산, 할당, 비교를 수행해 하나의 값을 만든다.

```js
// 산술 연산자
5 * 4 // -> 20
// 문자열 연결 연산자
'My name is ' + 'Lee' // -> 'My name is Lee'
// 할당 연산자
color = 'red' // -> 'red'
// 비교 연산자
3 > 5 // -> false
// 논리 연산자
true && false // -> false
// 타입 연산자
typeof 'Hi' // -> 'string'
```

-----

## #1.산술 연산자(arithmetic operator)

> 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값 만든다.
> 산술 연산이 불가능한 경우 NaN을 반환



### #(1). 단항산술 연산자

> **피연산자의 개수**에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.

| 이항 산술 연산자                       | 단항산술 연산자                                     |
| -------------------------------------- | --------------------------------------------------- |
| 2개의 피연산자를 산술 연산하여 숫자 값 | 1개의 피연산자를 산술 연산하여 숫자 값              |
| 5 + 2; // -> 7                         | var x = 1;                                          |
| 부수적 효과 X (새로운 값만 생성)       | 부수적 효과 O (피연산자의 값을 변경하는 암묵적할당) |

| 단항 산술 연산자 | 의미(위치가 가지고 있는)                    | 부수효과 |
| ---------------- | ------------------------------------------- | -------- |
| ++               | 증가                                        | O        |
| --               | 감소                                        | O        |
| +                | 효과X (음수를 양수로 반전하지X)             | X        |
| -                | 양수를 음수로, 음수를 양수로 반전한 값 반환 | X        |

- 증감 연산자 (increment and decrement operator)

  > 피연산자를 1씩 증가하거나 1씩 감소시킬 때 사용하는 연산자 = >피연산자가 하나뿐인 단항 연산자
  >
  > Ex) X++
  >
  > | 변수++(postfix) | 기존의 변수값에 1을 더한다(후위)    |
  > | --------------- | ----------------------------------- |
  > |                 | 값을 할당하고 그 다음에 1을 더한다. |
  > | ++변수(pretfix) | 기존의 변수값에 1을 더한다(전위)    |
  > |                 | 1을 더한 다음 값을 할당한다.        |
  > | 변수--(postfix) | 기존의 변수값에 1을 뺀다(후위)      |
  > |                 | 값을 할당하고 그 다음에 1을 뺀다.   |
  > | --변수(pretfix) | 기존의 변수값에 1을 뺀다(전위)      |
  > |                 | 1을 뺀 다음 값을 할당한다.          |
  >
  > - 전위 ? 
  >
  >   > 출력 **전**에 연산하는 것 : 계산을 먼저 하고 할당하는 것 
  >
  > - 후위?
  >
  >   >  출력 **후**에 연산하는 것 : 할당 후 계산하는 것 
  >   >
  >   > ```js
  >   > var number = 10;
  >   > alert(number++);//10출력 후 +1 = 11
  >   > alert(++number);//11에 +1하고 출력 = 12
  >   > alert(number--);//12출력 후 -1 = 11
  >   > alert(--number);//11에 -1하고 출력 =10
  >   > ```
  >   >
  >   > => 결론 : 연산자의 위치에 의미가 있다

  

  #### <단항산술 연산자의 특징 >

  ```js
  1) 증감연산자를 통해서 변경된 값을 암묵적으로 할당할 수 있다. ( ++변수 OR 변수++ )
  2) +단항연산자는 음수를 양수로 바꿀 수 없다.(피연산자에게 효과주지 못함)
  	ex) +10; //10 : +단항연산자 => 양수 
  		  +(-10); //-10 : -단항연산자 => 양수 + 음수 => 음수
  3)'숫자 타입이 아닌 피연산자'를 값을 반환하는 방법의 차이 (+ 단항 연산자 vs - 단항연산자)
  ```

  | 숫자타입이 아닌 피연산자에게 |           +단항연산자           |          -단항연산자           |
  | ---------------------------- | :-----------------------------: | :----------------------------: |
  | 피연산자를                   |   숫자타입으로 변환하여 반환    |   숫자타입으로 변환하여 반환   |
  | 공통점                       |   피연산자가 변경되는 것은 X    |   피연산자가 변경되는 것은 X   |
  | 차이점 (반환의 차이)         | 숫자타입으로 변환값 생성해 반환 | 부호를 반전한 값을 생성해 반환 |
  | 부수효과                     |                X                |               X                |

  #### +단항 연산자 

  ```js
  var x  = '1';
  
  // 문자열을 숫자로 타입 변환한다.
  console.log(+x); // 1
  // 부수 효과는 없다.
  console.log(x);  // "1"
  
  // 불리언 값을 숫자로 타입 변환한다.
  x = true;
  console.log(+x); // 1
  // 부수 효과는 없다.
  console.log(x);  // true
  
  // 불리언 값을 숫자로 타입 변환한다.
  x = false;
  console.log(+x); // 0
  // 부수 효과는 없다.
  console.log(x);  // false
  
  // 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
  x = 'Hello';
  console.log(+x); // NaN
  // 부수 효과는 없다.
  console.log(x);  // "Hello"
  ```

  #### -단항 연산자

  ```js
  // 부호를 반전한다.
  -(-10); // -> 10
  
  // 문자열을 숫자로 타입 변환한다.
  -'10'; // -> -10
  
  // 불리언 값을 숫자로 타입 변환한다.
  -true; // -> -1
  
  // 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
  -'Hello'; // -> NaN
  ```

  

### #(2). 문자열 연결 연산자

```js
1) + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
2) '암묵적 타입변환[implict coercion]'(타입 강제 변환[type coercion])
	: 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환되기도 한다.
```

```js
// 특징 1번 예시 
//문자열 연결 연산자
'1' + 2; // -> '12'
1 + '2'; // -> '12'
```

```js
//특징 2번 예시
// true는 1로 타입 변환된다.
1 + true; // -> 2

// false는 0으로 타입 변환된다.
1 + false; // -> 1

// null은 0으로 타입 변환된다.
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined;    // -> NaN
1 + undefined; // -> NaN
```



### #(3). 할당 연산자(assignment operator)

> 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 
> =좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다.

| 할당 연산자 | 예     | 동일표현  | 부수효과 |
| ----------- | ------ | --------- | -------- |
| =           | x = 5  | x = 5     | ○        |
| +=          | x += 5 | x = x + 5 | ○        |
| -=          | x -= 5 | x = x - 5 | ○        |
| *=          | x *= 5 | x = x * 5 | ○        |
| /=          | x /= 5 | x = x / 5 | ○        |
| %=          | x %= 5 | x = x % 5 | ○        |

```js
Q) 할당문은 표현식인 문일까 표현식이 아닌 문일까? 
A) 표현식은 값으로 평가될 수 있는 문인데
   var X;
   console.log( x = 10); //10 
   => 할당문은 값으로 평가되는 ' 표현식인 문 '으로서 '할당된 값'으로 평가된다.
```



### #(4). 비교 연산자 (comparison operator)

> 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다. 
> if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용

- 동등 / 일치 비교 연산자

  > [동등 비교( loose equality ) 연산자][느슨한 비교] 와 [일치 비교( strict equality )][엄격한 비교] 
  >
  > |          | 동등비교 연산자(==)              | 일치비교 연산자(===)                |
  > | -------- | -------------------------------- | ----------------------------------- |
  > | 단점     | 결과측 어려움 / 실수할 확률 높음 |                                     |
  > | 장점     | 편리하다                         | 예측이 쉽다.                        |
  > | 비교방법 | 암묵적 타입 변환 하고 값 비교    | 암묵적인 타입변환 하지 않고 값 비교 |
  > | 의미     | 값만 같음.                       | 값 + 데이터 모두 같음.              |
  >
  > ```js
  > //동등비교
  > //암묵적 타입 변환 
  > var X = 1;
  > var Y =' 1 ';
  > console.log( X == y);
  > <true  
  > //타입변환 
  > // == : 값만 같으면 true입니다 = 멋대로 타입을 일치시킵니다 > 안시킨 일 
  > 
  > //일치비교
  > var X = 1;
  > var Y =' 1 ';
  > console.log( X === y); //1
  > <false //타입이 다르기 때문입니다.
  > // === : '데이터 타입도 같고 값도 같다.'를 의미합니다.
  > ```
  >
  > | 비교 연산자 | 의미        | 사례     | 설명                 |
  > | ----------- | ----------- | -------- | -------------------- |
  > | ==          | 동등 비교   | x == y   | 값만 같음            |
  > | ===         | 일치 비교   | x ===  y | 데이터 타입, 값 같음 |
  > | !=          | 부동등 비교 | x != y   | 값 다름              |
  > | !==         | 불일치 비교 | x !== y  | 데이터 타입, 값 다름 |
  >
  > ***주의사항** 
  >
  > 1) NaN 
  >
  > > ```js
  > > //NaN은 자기 자신과 일치하지 않는 유일한 값이다.
  > > NaN === NaN; // -> false
  > > 
  > > 그래서
  > > //숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다
  > > // isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 불리언 값으로 반환한다.
  > > isNaN(NaN); //검사할 값 입력 // -> true
  > > isNaN(10);  // -> false
  > > isNaN(1 + undefined); // -> true
  > > 
  > > //isNaN?
  > > //매개변수가 숫자인지 검사하는 함수
  > > //매개변수가 숫자가 아니면 true , 숫자면 false를 반환
  > > ```
  > >
  > > 2) 숫자 0
  > >
  > > ```js
  > > //자바스크립트에서 양의 0과 음의 0이 있는데 그들을 비교하 True를 반환한다.
  > > // 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 결과는 true이다.
  > > 0 === -0; // -> true
  > > 0 == -0;  // -> true
  > > ```
  > >
  > > - [Object.is(  )][ES6에 도입/ 두 값이 같은 값인지 결정하는 것 ] method
  > >
  > > ```js
  > > 동등 / 일치비교자 
  > > : -0과 +0 ' 동일한 값 '으로 평가
  > > : NaN 과 NaN '다른 값' 으로 평가 
  > > ```
  > >
  > > ```js
  > > Object.is ( )method
  > > //예측가능한 정확한 비교 결과를 반환(예외)
  > > -0 === +0;         // -> true
  > > Object.is(-0, +0); // -> false
  > > 
  > > NaN === NaN;         // -> false
  > > Object.is(NaN, NaN); // -> true
  > > 
  > > -------------------------------------
  > >   
  > > Object.is('foo', 'foo');     // true
  > > Object.is(window, window);   // true
  > > 
  > > Object.is('foo', 'bar');     // false
  > > Object.is([], []);           // false
  > > 
  > > var test = { a: 1 };
  > > Object.is(test, test);       // true
  > > 
  > > Object.is(null, null);       // true
  > > 
  > > // 특별한 경우
  > > Object.is(0, -0);            // false
  > > Object.is(-0, -0);           // true
  > > Object.is(NaN, 0/0);         // true
  > > ```

  

- 대소 관계 비교 연산자

  > 피연산자의 크기를 비교하여 불리언 값을 반환한다.
  >
  > | 대소 관계 비교 연산자 |  예제  |         설명          | 부수 효과 |
  > | :-------------------: | :----: | :-------------------: | :-------: |
  > |           >           | x > y  |    x가 y보다 크다     |     ✕     |
  > |           <           | x < y  |    x가 y보다 작다     |     ✕     |
  > |          >=           | x >= y | x가 y보다 크거나 같다 |     ✕     |
  > |          <=           | x <= y | x가 y보다 작거나 같다 |     ✕     |

  

### #(5). 삼항 조건 연산자 (ternary operator)

> 조건식의 평가 결과에 따라 반환할 값을 결정한다.
> 자바스크립트의 유일한 삼항 연산자이다.

- [**삼항 조건 연산자 표현식**][두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식]

  ```js
  1) 첫번째 피연산자 === 'true'로 평가되면, '두번째 피연산자 '반환
  2) 첫번째 피연산자 ==='false'로 평가되면,'세번째 피연산자' 반환
   
   Q) ? 앞 첫 번째 피연산자는 무엇입니까?
   A) 조건식, 불리언 타입의 값으로 평가될 표현식 => 삼항 조건 연산자 표현식 = 조건문
   //만얀 결과가 불리언 값이 아니어도 암묵적으로 타입변환 
   //조건식의 평가결과가 'true'일 때 반환할 값: 콜론(:)'앞'의 '두' 번째 피연산자가 평가되어 반환
   //조건식의 평가결과가 'false'일 때 반환할 값: 콜론(:)'뒤'의 '세' 번째 피연산자가 평가되어 반환
  ```

  <img src="/Users/jeonsejin/Library/Application Support/typora-user-images/스크린샷 2020-11-18 오후 11.16.13.png" alt="스크린샷 2020-11-18 오후 11.16.13" style="zoom:50%;" /> 

- [**If...else문**][표현식이 아닌 문]

  ```js
  if(조건식){
    실행문; //조건식이 true일 경우 진행
  }else{
    실행문; //조건식이 false일 경우 진행 
  }
  
  var x = 2, result;
  
  // 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
  if (x % 2) result = '홀수';
  else       result = '짝수';
  
  console.log(result); // 짝수
  ```

  |               | 삼항 조건 연산자 표현식 | if...else문           |
  | ------------- | ----------------------- | --------------------- |
  | 값처럼        | 사용 가능               | 사용 불가             |
  | 문            | 표현식인 문             | 표현식이 아닌 문      |
  | 조건수행 갯수 | 하나 일때 유용          | 여러개 일때 가독성 up |

  ```js
  //if...else 값 사용
  var x = 10;
  
  // if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.
  var result = if (x % 2) { result = '홀수'; } else { result = '짝수'; };
  // SyntaxError: Unexpected token if
  
  //삼항 조건 연산자 표현식
  var x = 10;
  
  // 삼항 조건 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.
  var result = x % 2 ? '홀수' : '짝수';
  console.log(result); // 짝수
  ```

  

### #(6). [논리 연산자 (logical operator) ][우항과 좌항의 피연산자를 논리연산한다.]

> 단, 부정논리 연산자의 경우 우항의 피연산자를 논리 연산한다. 

| 논리 연산자 | 의미        | 부수 효과 |
| :---------: | :---------- | :-------: |
|    \|\|     | 논리합(OR)  |     ✕     |
|     &&      | 논리곱(AND) |     ✕     |
|      !      | 부정(NOT)   |     ✕     |

```js
// 논리합(||) 연산자
//true가 한 항에만 존재해도 true 
true || true;   // -> true
true || false;  // -> true
false || true;  // -> true
false || false; // -> false

// 논리곱(&&) 연산자
//true가 두 항에 있어야만 true
true && true;   // -> true
true && false;  // -> false
false && true;  // -> false
false && false; // -> false

//논리 합과 논리곱의 연산자 표현식의 평가결과는 불리언 값 아닐 수 있음.
// 단축 평가
'Cat' && 'Dog'; // -> 'Dog'

// 논리 부정(!) 연산자
!true;  // -> false
!false; // -> true

// 암묵적 타입 변환
// 언제나 불리언 값 반환 하지만 피연산자가 반드시 불리언일 필요는 없음.
// 암묵적으로 불리언 타입으로 변환
!0;       // -> true
!'Hello'; // -> false
```



#### 논리연산자를 간단하게 하는 방법 2가지 

*[단축 평가][short circuit evaluation , 논리합과 논리곱연산자는 왼쪽으로 부터 오른쪽으로 평가를 진행하는 반면 중간에 평가 결과가 나오면 오른쪽 끝까지 가지 않고 평가결과를 반환해 버리는 것]

> 피연산자의 타입을 변환하지 않고 그대로 반환한다. 

```js
//논리 합||의 단축평가 
1)오른쪽을 보지 않고 왼쪽 피연산자의 값을 그대로 반환한다.
"apple" || "banana"; // "apple" 
"apple" && "banana"; // "banana"

2)왼쪽 피연산자가 문자열 일때, 오른쪽 보지 않고 바로 값 반환
"apple" || false; // "apple" 
"apple" || true; // "apple"

3)왼쪽 피연잔사가 false일 때, 오른쪽 피연산자 값이 값 결정
false || true; // true (오른쪽 값이 반환된다) 
false || false; // false (오른쪽 값이 반환된다)

//논리 곱&&의 단축평가 
1)둘다 true여야 true 
false && true; // false
false && false; // false 

2)왼쪽 피연산자가 false일 때, 오른쪽에 문자열이 오더라도 false 반환
false && "banana"; // false

3)왼쪽 피연산자가 null일 때, null이 반환
null && false;  // null
//false로 타입 변환되지 않고 그대로 null 반환
```

*[드 모르간의 법칙][논리곱(집합의 공통 부분), 논리합(집합의 모든 부분), 부정(여집합) 연산간의 관계(드 모르간의 상대성이라고 부름)를 기술하여 정리한 것]

> 장점: 가독성이 좋은 표현으로 변환
>
> ```js
> !(x || y) === (!x && !y)
> !(x && y) === (!x || !y)
> ```



### #(6). [쉼표 연산자 ][왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환하는 것]

```js
var x, y, z;

x = 1, y = 2, z = 3; // 3
```



### #(7).[ 그룹 연산자][소괄호()로 피연산자를 감싸는 것]

> 자신의 피연산자인 표현식 가장 먼저 평가한다. 
> 그룹연산자를 사용하면 연산자의 **우선순위를 조절**할 수 있다. (우선순위 가장 높음)

```js
10 * 2 + 3; // -> 23
//곱셈 연산자 > 덧셈 연산자 (우선순위)

// 그룹 연산자를 사용하여 우선순위를 조절
10 * (2 + 3); // -> 50
```



### #(8). [Typeof 연산자][피연산자의 데이터타입을 문자열로 반환]

> Typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. “null”을 반환하는 경우는 없으며, 함수의 경우 “function”을 반환한다.

>  typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다.

```js
typeof ''              // -> "string"
typeof 1               // -> "number"
typeof NaN             // -> "number"
typeof true            // -> "boolean"
typeof undefined       // -> "undefined"
typeof Symbol()        // -> "symbol"
'typeof null            // -> "object"'
	//자바스크립트의 첫번째 버전의 버그
	//기존코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.
typeof []              // -> "object"
typeof {}              // -> "object"
typeof new Date()      // -> "object"
typeof /test/gi        // -> "object"
typeof function () {}  // -> "function"
```

```js
//typeof null
//null 타입인지 확인 할 때는 일치 연산자를 사용하자.(버그 때문)
 	var foo = null;

	typeof foo === null; // -> false
	foo === null;        // -> true

//선언하지 않은 식별자를 typeof 연산자로 연산해보면 referenceError발생하지 
//않고 undefined를 반환한다.
// undeclared 식별자를 선언한 적이 없다.
typeof undeclared; // -> undefined
```



### #(9). [지수 연산자][좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환]

```js
2 ** 2;   // -> 2^2 = 4
2 ** 2.5; // -> 2^2.5 = 5.65685424949238
2 ** 0;   // -> 2^0 = 1
2 ** -2;  // -> 2^-2 = 0.25

//특징
//1. 음수를 거듭제곱의 밑으로 사용하는 방법 : 괄호 사용하기 
(-5) ** 2; // -> 25

//2. 할당연산자와 함께 사용할 수 있다. 
var num = 5;
num **= 2; // -> 25

//3. 이항연산자 중에서 우선순위 가장 높다.
2 * 5 ** 2; // -> 5^2= 25^2 => 50
```

- **Math.pow method** 

  > 거듭제곱한 "결과"를 반환한다 = > 꼭 숫자값을 반환하는 것은 아니다.
  >
  > ```js
  > Math.pow(2, 8);  // -> 256
  > Math.pow(2, -1); // -> 0.5
  > Math.pow(2);     // -> NaN
  > ```



- 가독성의 차이 : 지수연산자 > math.pow

  ```js
  2 ** 2 ** 2; // -> 2^2=4^2 => 16
  Math.pow(Math.pow(2, 2), 2); // -> 16
  ```

  

### #(10). 그 외의 연산자

| 연산자     | 개요                                                         |
| :--------- | :----------------------------------------------------------- |
| ?.         | 옵셔널 체이닝 연산자 : 좌항의 피연산자 null/undefined인 경우 undefined 반환 (else 우항 프로퍼티 값) |
| ??         | null 병합 연산자 :좌항의 피연산자 null/undefined인 경우 우항의 피연산자 반환 (else 좌항 반환) |
| delete     | 프로퍼티 삭제 : 프로퍼티 값에 접근할 수 있는 표현식 (조건)   |
| new        | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성  : 내부메서드 호출 아니고 [[construct]] 호출 |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 : 객체 instanceof 생성자 함수 |
| in         | 프로퍼티 존재 확인 : 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인 : key in object |



### #(11)연산자의 부수효과

- 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자

  ```js
  var x;
  
  // 할당 연산자는 변수 값이 변하는 부수 효과가 있다.
  // 이는 x 변수를 사용하는 다른 코드에 영향을 준다.
  x = 1;
  console.log(x); // 1
  
  // 증가/감소 연산자(++/--)는 피연산자의 값을 변경하는 부수 효과가 있다.
  // 피연산자 x의 값이 재할당되어 변경된다. 이는 x 변수를 사용하는 다른 코드에 영향을 준다.
  x++;
  console.log(x); // 2
  
  var o = { a: 1 };
  
  // delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.
  // 이는 o 객체를 사용하는 다른 코드에 영향을 준다.
  delete o.a;
  ```



### #(12)[연산자의 우선순위][연산자가 실행되는 순서]

| 우선순위 | 연산자                                                       |
| :------- | :----------------------------------------------------------- |
| 1        | ( )                                                          |
| 2        | new(매개변수 존재), ., , ()(함수 호출), ?.([옵셔널 체이닝 연산자](https://poiemaweb.com/fastcampus/type-casting#42-옵셔널-체이닝-연산자)) |
| 3        | new(매개변수 미존재)                                         |
| 4        | x++, x–                                                      |
| 5        | !x, +x, -x, ++x, –x, typeof, delete                          |
| 6        | ** (이항 연산자 중에서 우선순위가 가장 높다)                 |
| 7        | *, /, %                                                      |
| 8        | +, -                                                         |
| 9        | <, <=, >, >=, in, instanceof                                 |
| 10       | ==, !=, ===, !==                                             |
| 11       | ?? ([null 병합 연산자](https://poiemaweb.com/fastcampus/type-casting#43-null-병합-연산자)) |
| 12       | &&                                                           |
| 13       | \|\|                                                         |
| 14       | ? … : …                                                      |
| 15       | 할당 연산자(=, +=, -=, …)                                    |
| 16       | ,                                                            |

> 너무 많으니까 그룹연산자 사용해서 명확하게 하자 



### #(13)[연산자의 결합순서][연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지를 나타내는 순서]

| 결합 순서   | 연산자                                                       |
| :---------- | :----------------------------------------------------------- |
| 좌항 → 우항 | +, -, /, %, <, <=, >, >=, &&, \|\|, ., [], (), ??, ?., in, instanceof |
| 우항 → 좌항 | ++, --, 할당 연산자(=, +=, -=, …), !x, +x, -x, ++x, –x, typeof, delete, ? … : … |